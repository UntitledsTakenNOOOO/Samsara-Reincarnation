#define SAMSARA_LINE_TRACE_X_IDX 0
#define SAMSARA_LINE_TRACE_Y_IDX 1
#define SAMSARA_LINE_TRACE_Z_IDX 2

int playerLineTraceCoords[64][3] = {
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
	{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}
};

Script "SamsaraSetPlayerLineTraceCoords" (void)
{
	// Coordinates of puff calling script
	int x = GetActorX(0);
	int y = GetActorY(0);
	int z = GetActorZ(0);

	// Set activator to player who fired puff
	SetActivator(0, AAPTR_TARGET);

	int playerNum = PlayerNumber();

	playerLineTraceCoords[playerNum][SAMSARA_LINE_TRACE_X_IDX] = x;
	playerLineTraceCoords[playerNum][SAMSARA_LINE_TRACE_Y_IDX] = y;
	playerLineTraceCoords[playerNum][SAMSARA_LINE_TRACE_Z_IDX] = z;
}

/*
Guided Missile
By Scotty

Set SC_DEBUG_MODE 1 in the console to use debug mode! It displays useless data in a hudmessage.

The constants below can be used to make quick changes to the behavior.

LATENCY: The length in time, in tics, with which the missiles recalculate their trajectories.

NUMBER_MISSILES: The max number of missiles that you can have following the target.
                 Any over will just fly straight where you were aiming.

MISSILE_SPEED: The speed with which the missile will travel. (Duh)

MISSILE_CUTOFF: The minimum distance away from the target for the missile to recalculate
                its angle and pitch. (If it gets too close to the target, it will stop
                updating its trajectory and just fly straight for wherever it was heading.

MISSILE_TURNVALUE: A fixed point number representing the max angle that missiles can adjust
                   per update. This creates a curve effect. Use 0 to ignore this and just
                   use whateverangle and pitch it needs to head straight for the target.
*/

#define LATENCY           1
#define NUMBER_MISSILES   100
#define MISSILE_SPEED     20
#define MISSILE_CUTOFF    32
#define MISSILE_TURNVALUE 0.02

bool missile[NUMBER_MISSILES] = {0};

//==============================================================================
//Finds the first zero element in the missile[] array.
//This would be much more useful if I could pass in a pointer to the array!
//
//Returns: INT value for the first element with a 0; -1 if none were found.
function int findFirstZeroSlot(void) {
	int result = -1;
	int i;

	// Cycle through each value in the missile array
	for (i = 0; i < NUMBER_MISSILES; i++)
	{
		if (missile[i] == 0)
		{
			result = i;
			break;
		}
	}

	return result;
}

//Taken and modified from a function on the zdoom wiki
//http://zdoom.org/wiki/GetTargetPitch
function int getTargetPitch(int tid1, int targetX, int targetY, int targetZ)
{
	int x = GetActorX(tid1) - targetX;
	int y = GetActorY(tid1) - targetY;
	int z = GetActorZ(tid1) - targetZ;
	int a = VectorAngle(x, y);
	int xy = (a + 0.125) % 0.5 > 0.25 ? FixedDiv(y, sin(a)) : FixedDiv(x, cos(a));

	return -VectorAngle(xy, z);
}

//==============================================================================
//Returns the signed difference between two angles
//
//Parameters:
//angleA - FIXED, The first angle to compare
//angleB - FIXED, The second angle to compare
//
function int diffAngle(int angleA, int angleB) {
	int result = angleA - angleB;

	if (result > 0.5) { result -= 1.0; }
	else if (result < -0.5) { result += 1.0; }

	return result;
}

//==============================================================================
//This is a function that creates a curve effect on the missile.
//Essentially what it does is takes a target angle, the missile's current
//angle, finds the difference between the two, and adds or subtracts a small
//fixed numbner (changeValue) from the current angle and returns the result,
//so it eases closer to the result rather than just being the result.
//
//Parameters:
//targetAngle -  FIXED, The target angle that the missile needs to have
//currentAngle - FIXED, the current angle that the missile has
//changeValue -  FIXED, a small value to change the current angle by.
//
function int closeIn(int targetAngle, int currentAngle, int changeValue)
{
	int diff = diffAngle(currentAngle, targetAngle);

	if (abs(diff) < changeValue) { return targetAngle; }
	else if (diff > 0) { return currentAngle - changeValue; }
	else if (diff < 0) { return currentAngle + changeValue;}

	return 0;
}

//==============================================================================
//This is the meat and potatoes of the mod!
//This takes the TID of a missile, the X, Y, and Z positions of a target,
//Does math to figure out where the missile needs to go and changes the velocity
//accordingly.
//
//Parameters:
//missileTid - INT, The TID of the missile
//targetX -    FIXED, The target X coordinate
//targetY -    FIXED, The target Y coordinate
//targetZ -    FIXED, The target Z coordinate
//speed -      INT, the speed with which the missile will move
//cutoff -     FIXED, the distance with which to make the missile stop following the target.
//turnValue -  FIXED, the amount per call the missile is allowed to turn. Pass 0 to ignore this and just use the target angle.
//
//Returns: BOOL value that indicates if the missile can follow its target.
//
function bool setVelocityToTarget(int missileTid, int targetX, int targetY, int targetZ, int speed, int cutoff, int turnValue)
{
	int missileX = GetActorX(missileTid);
	int missileY = GetActorY(missileTid);
	int missileZ = GetActorZ(missileTid);

	//Fixed point variables which define the individual X, Y, and Z distances
	//that the missile is from the target.
	int disX = targetX - missileX;
	int disY = targetY - missileY;
	int disZ = targetZ - missileZ;

	//Int equivalents of the values above. These are used to determine the cutoff distance.
	int idisX = ftoi(disX);
	int idisY = ftoi(disY);
	int idisZ = ftoi(disZ);

	int xySquared = (idisX * idisX) + (idisY * idisY);

	//Actual distance the missile is from the target.
	int distance = sqrt(xySquared + idisZ * idisZ);

	//This is to check for a cutoff distance.
	//This is used because without it, if you were to shoot the missile downward at a
	//specific range of angles, it doesn't want to touch the ground. Instead it
	//goes berserk in place, hovering just above the floor.
	if (distance > cutoff)
	{
		//Target and Current Angle
		int targetAngle = VectorAngle(disX, disY);
		int currentAngle = GetActorAngle(missileTid);

		//Target and Current Pitch
		int targetPitch = getTargetPitch(missileTid, targetX, targetY, targetZ);
		//Normalize the pitch to a positive value.
		if (targetPitch < -0.5) { targetPitch += 1.0; }

		//Grab the current pitch
		int currentPitch = GetActorPitch(missileTid);
		//This is intended to fix a small anomaly that causes a missile to fly out of the
		//launcher at 0.0 pitch at first then readjust, without regard to the player pitch.
		if (currentPitch == 0) { currentPitch = targetPitch; }

		//Next Angle and Pitch
		int nextAngle, nextPitch;
		//If the turnValue is not 0, we'll calculate the next angle by the difference
		//between the target and current angles, plus or minus the turnvalue.
		//This creates a curve effect!
		if (turnValue != 0)
		{
			nextAngle = closeIn(targetAngle, currentAngle, turnValue);
			nextPitch = closeIn(targetPitch, currentPitch, turnValue);
		}
		//If the turnValue is 0, we'll just set the pitch and angle to what it needs to be.
		//This was the original incarnation of this weapon used and it works really well
		//if you're annoyed by the curve effect.
		else
		{
			nextAngle = targetAngle;
			nextPitch = targetPitch;
		}

		int adjHypPitchRatio = cos(nextPitch);

		//Next X, Y, and Z velocities
		//Trig here to make sure the combined X, Y, and Z velocities equal the speed that is passed in.
		int nextVelX = FixedMul(cos(nextAngle), adjHypPitchRatio) * speed;
		int nextVelY = FixedMul(sin(nextAngle), adjHypPitchRatio) * speed;
		int nextVelZ = sin(nextPitch) * speed;

		//Chage the velocity here using the calculated values above.
		SetActorVelocity(missileTid, nextVelX, nextVelY, nextVelZ, 0, 0);

		//Store the pitch and angle data on the actor's Pitch and Angle.
		//Angle affects the look, and the values on both will be used next round to
		//determine the velocities to set.
		SetActorPitch(missileTid, nextPitch);
		SetActorAngle(missileTid, nextAngle);

		//Dumps debug data if the cvar SC_DEBUG_MODE is set to true.
		if (GetCVar("SC_DEBUG_MODE") == 1)
		{
			HudMessageBold(
				s:"TargetX:   ", f: targetX,
				s:"\nTargetY:   ", f: targetY,
				s:"\nTargetZ:   ", f: targetZ,
				s:"\nMissileX:  ", f: missileX,
				s:"\nMissileY:  ", f: missileY,
				s:"\nMissileZ:  ", f: missileZ,
				s:"\nDisX:     ", f: disX,
				s:"\nDisY:     ", f: disY,
				s:"\nDisZ:     ", f: disZ,
				s:"\nDist:     ", f: itof(sqrt(xySquared)),
				s:"\nT-Angle:  ", f: targetAngle,
				s:"\nC-Angle:  ", f: currentAngle,
				s:"\nT-Pitch:  ", f: targetPitch,
				s:"\nC-Pitch:  ", f: currentPitch,
				s:"\nX-Vel:    ", f: nextVelX,
				s:"\nY-Vel:    ", f: nextVelY,
				s:"\nZ-Vel:    ", f: nextVelZ;
				HUDMSG_LOG, 10, 0, 0.1, 0.5, 35
			);
		}

		return true;
	}

	return false;
}

script "SamsaraGuidedMissileFollow" (void) {
	//Grab the first slot available for a missile to occupy
	int missileSlotIndex = findFirstZeroSlot();

	//If the result is good...
	if (missileSlotIndex != -1)
	{
		Thing_ChangeTID(0,20000 + missileSlotIndex);

		int missileTid = ActivatorTID();
		int occupyTid = missileTid - 20000;

		//Set activator to player who fired missile...
		SetActivator(0, AAPTR_TARGET);

		//...and get their player number
		int playerNum = PlayerNumber();

		//Set activator back to missile
		SetActivator(missileTid);

		//Store the missile's TID - 20000 in the array. This will flag it as occupied.
		missile[occupyTid] = 1;
		bool follow;

		//Then the missile follows the target until it's exploded or it gets too close to the target.
		do
		{
			int targetX = playerLineTraceCoords[playerNum][SAMSARA_LINE_TRACE_X_IDX];
			int targetY = playerLineTraceCoords[playerNum][SAMSARA_LINE_TRACE_Y_IDX];
			int targetZ = playerLineTraceCoords[playerNum][SAMSARA_LINE_TRACE_Z_IDX];

			follow = setVelocityToTarget(0, targetX, targetY, targetZ, MISSILE_SPEED, MISSILE_CUTOFF, MISSILE_TURNVALUE);
			Delay(LATENCY);
		} while (missile[occupyTid] == 1 && follow);
	}
}

script "SamsaraGuidedMissileCleanup" (void)
{
	int missileTid = ActivatorTID();

	if (missileTid != 0)
	{
		//Open a slot in the array
		missile[missileTid - 20000] = 0;
		//Make sure the velocity is 0
		SetActorVelocity(0, 0, 0, 0, 0, 0);
		Thing_ChangeTID(0, 0);
	}
}
